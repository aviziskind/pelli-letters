function S = DrawAlphabet_az(wiggleType, wiggleAmount, opts)%%%     checkPix=1;%     signalCheckPix=checkPix;%     pixPerDegree = 40;            if nargin < 3        opts = struct;    end        f_cycPerDeg = 1; % default    if isfield(opts, 'f_cycPerDeg')        f_cycPerDeg = opts.f_cycPerDeg;    end        pixPerDegree = 40;    if isfield(opts, 'pixPerDegree')        pixPerDegree = opts.pixPerDegree;    end%     degreesPerPix = 1 / pixPerDegree; %0.1;        lambda_deg = 0.3; % space constant of gaussian envelope    if isfield(opts, 'lambda_deg')        lambda_deg = opts.lambda_deg;    end        markSpacing_deg = 0.91;    if isfield(opts, 'markSpacing_deg')        markSpacing_deg = opts.markSpacing_deg;    end        numGaborsPerLetterHeight = 3.9;    if isfield(opts, 'numGaborsPerLetterHeight')        numGaborsPerLetterHeight = opts.numGaborsPerLetterHeight;    end        extraMultForOffsetBorder = 1;    if isfield(opts, 'extraMultForOffsetBorder')        extraMultForOffsetBorder = opts.extraMultForOffsetBorder;    end                %     signalCoreDeg=10;	% nominal size of signal in deg%     numGaborsPerLetterHeight = 10;%     gaborSize_pix = 20;%     gaborSpacing_pix = 5;  % spacing between gabors%     gaborCenterSpacing_pix = gaborSize_pix + gaborSpacing_pix;  % center-to-center spacing between gabors         % interval between successive gaussians        lambda_pix      = lambda_deg * pixPerDegree;    markSpacing_pix = markSpacing_deg * pixPerDegree;    %     if nargin < 1    wiggleTypes = {'none', 'orientation', 'offset', 'phase'};    if ~any(strcmp(wiggleType, wiggleTypes))        error('Invalid wiggleType : %s', wiggleType);    end    %     wiggleType = 'orientation';%     wiggleType = 'offset';%     wiggleType = 'phase';    %     noiseRmsContrast=0.1;%     randomSign=1;%     eccentricity=0;		% deg %     randomizeSide=0;	% randomly left or right? if eccentricity~=0%     useMouse=0;			% 0 if you prefer keyboard%     noiseType='uniform'; % change to 'uniforpixPerDegree    %     signalCoreSize_pix=100;%     signalCoreDeg= signalCoreSize_pix * degreesPerPix;	% nominal size of signal in deg        gaborSize_deg=4*lambda_deg;    gaborSize_pix = gaborSize_deg * pixPerDegree;%     signalCoreDeg= (numGaborsPerLetterHeight-1) * markSpacing_deg + gaborSize_deg;%     signalCoreDeg= (numGaborsPerLetterHeight) * gaborSize_deg;    signalCoreDeg= (numGaborsPerLetterHeight) * markSpacing_deg;%     signalCoreDeg = 4;    signalCoreSize_pix=signalCoreDeg  * pixPerDegree;        %     0.91; * degreesPerPix;	% nominal size of signal in deg        % Possible sets: ISO, ORTHO, MIX, ALTERNATE, 45degree, 135degree, offset, altoffset, blackaltoffset%     markSpacing=1*10; %center to center spacing of gabor elements in pixels    randSpacing=0; %=1 if spacing is random	    gaborOrientation_deg = 0;    gaborOffset = 0;    gaborPhase=0; %in deg, for phase shift.        switch wiggleType        case 'orientation',            gaborSet='ISO_alternate';            gaborOrientation_deg = wiggleAmount;        case 'offset',            gaborSet='offset';            gaborOffset_deg = wiggleAmount;            gaborOffset = wiggleAmount * pixPerDegree;                    case 'phase',            gaborSet='phase';            gaborPhase = 180;                    case 'none',            gaborSet='ISO_alternate';            gaborOrientation_deg = 0;                    otherwise,            error('Unknown wiggle type');                end    %     gaborSet='ISO'; % all gabors are tilted by gaborOrientation%     gaborSet='ORTHO';  % all gabors are tilted by gaborOrientation + 90%     gaborSet='MIX';%     gaborSet='ALTERNATE'; % gabors alternate between gaborOrientation, and gaborOrientation + 90%     gaborSet='45degree';  % gabors alternate between gaborOrientation and gaborOrientation+45%     gaborSet='135degree';  % gabors alternate between gaborOrientation and gaborOrientation+135%     gaborSet='offset';  % same as ISO%     gaborSet='altoffset';  % same as offset, but also phase is shifted by gaborPhase(?)%     markSpacing=gaborCenterSpacing_pix; %center to center spacing of gabor elements in pixels    randSpacing=0; %=1 if spacing is random	%     gaborPhase=140; %in deg, for phase shift.%     signalType='picture';%     DrawAlphabet; % Create the Alphabet    % *** Remember to Change t.gaborset to proper configuration;    % function CreateAlphabet    % Set can be 'ISO', 'ORTHO','ALTERNATE', or 'MIX';    t.gaborSet=gaborSet;    t.markSpacing=markSpacing_pix;    t.randSpacing=randSpacing;    t.gaborOrientation=gaborOrientation_deg*pi/180; % number in () is absolute deviation from path of every Gabor.    t.offset=gaborOffset;    t.gaborPhase = gaborPhase;    t.alternate=1;    t.signalCoreDeg=signalCoreDeg;    t.signalCoreSize=signalCoreSize_pix; % 100    t.pixDeg=t.signalCoreDeg/t.signalCoreSize;  % = degrees per pixel    t.pixPerDeg = pixPerDegree;    % used only within gabor subroutine, inside Mark.m    t.animate=0;%     t.gaborOrientation=(0)*pi/180; % number in () is absolute deviation from path of every Gabor.    t.GaborRandomDev=10; % random deviation from t.gaborOrientation, in max. degrees.    t.spaceConstantDegX=lambda_deg; % X is direction along which the grating changes fastest.    t.spaceConstantDegY=lambda_deg; % Y is the direction along which the grating doesn't change.    t.gaborSize=5*max(t.spaceConstantDegX,t.spaceConstantDegY)/t.pixDeg;        t.signalSize=ceil(t.signalCoreSize+t.gaborSize* extraMultForOffsetBorder);    t.f=f_cycPerDeg; % spatial frequency of Gabor in c/deg.    t.capGaborMagnitude = opts.useModifiedLetters > 0;    t.gaborMax = 0;%     allSloanLetters = 'CDHKNORSVZ';    allSloanLetters = 'CHNRVDKOSZ';    S.letters = allSloanLetters;        gaborMax = 0;    for i = 1:length(allSloanLetters)        [let_i, t] = DrawLetter(t,allSloanLetters(i), opts.useModifiedLetters);        gaborMax = max(gaborMax, t.gaborMax);        S.signals(:,:,i) = let_i;        S.(allSloanLetters(i)) = let_i;    end%     S.signal1=DrawLetter(t,'C');%     S.signal2=DrawLetter(t,'D');%     S.signal3=DrawLetter(t,'H');%     S.signal4=DrawLetter(t,'K');%     S.signal5=DrawLetter(t,'N');%     S.signal6=DrawLetter(t,'O');%     S.signal7=DrawLetter(t,'R');%     S.signal8=DrawLetter(t,'S');%     S.signal9=DrawLetter(t,'V'); %     S.signal10=DrawLetter(t,'Z');        S.gaborMax = gaborMax;        show = 0;    if show        %%        figure(1);        S.turtle=t;        X = S.signal7;%         X = S.signal10;        imagesc(X);        colormap('gray');        colorbar;        L = max(abs(lims(X)));        caxis([-L, L]);        imageToScale([], 1);    end    3;%     S.snakes = snakes;end% save snakes turtle signal1 signal2 signal3 signal4 signal5 signal6 signal7 signal8 signal9 signal10;