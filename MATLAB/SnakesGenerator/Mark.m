% 2/21/00 dgp Added support for 'offset'.% modified by MCP 7/27/99function newTurtle=Mark(turtle)% draw a gabor at location turtle.position, relative to path orientation% given by turtle.direction.if turtle.print	fprintf('\nMark %3.0f,%3.0f;',turtle.position);endturtle=DrawGabor(turtle);turtle.nextMark=turtle.nextMark+turtle.markSpacing;newTurtle=turtle;returnfunction newTurtle=DrawGabor(turtle)% ISO, ORTHO, and MIX parameters;if strcmp(turtle.gaborSet,'ISO')	orient=turtle.gaborOrientation;elseif strcmp(turtle.gaborSet,'ISO_alternate')	orient=turtle.gaborOrientation;    turtle.gaborOrientation = -turtle.gaborOrientation;elseif strcmp(turtle.gaborSet,'ORTHO')	orient=turtle.gaborOrientation+(pi/2);	turtle.alternate=~turtle.alternate;elseif strcmp(turtle.gaborSet,'MIX')	r=(rand(1)*pi);	orient=r;elseif strcmp(turtle.gaborSet,'phase')    orient=turtle.gaborOrientation;	turtle.gaborPhase = turtle.gaborPhase + 180; %for 180 deg phase shiftelseif strcmp(turtle.gaborSet,'ALTERNATE')% 	orient=turtle.gaborOrientation+turtle.alternate*pi; %for 180 deg phase shift	orient=turtle.gaborOrientation+turtle.alternate*-pi/2; %for 90 deg rot	turtle.alternate=~turtle.alternate;elseif strcmp(turtle.gaborSet,'45degree')	orient=turtle.gaborOrientation+turtle.alternate*(pi/4);	turtle.alternate=~turtle.alternate;elseif strcmp(turtle.gaborSet,'80degree')	orient=turtle.gaborOrientation+turtle.alternate*(80*pi/180);	turtle.alternate=~turtle.alternate;elseif strcmp(turtle.gaborSet,'45degree')	orient=turtle.gaborOrientation+turtle.alternate*(pi/4);	turtle.alternate=~turtle.alternate;elseif strcmp(turtle.gaborSet,'135degree')	orient=turtle.gaborOrientation+turtle.alternate*(3*pi/4);	turtle.alternate=~turtle.alternate;elseif strcmp(turtle.gaborSet,'offset')	orient=turtle.gaborOrientation;	turtle.offset=-turtle.offset; % orthogonal offset. Positive is to right of straight ahead.elseif strcmp(turtle.gaborSet,'altoffset')	orient=turtle.gaborOrientation+turtle.alternate*pi; %for 180 deg rot	turtle.offset=-turtle.offset; % orthogonal offset. Positive is to right of straight ahead.	turtle.alternate=~turtle.alternate;elseif strcmp(turtle.gaborSet,'blackaltoffset')	orient=turtle.gaborOrientation+pi-turtle.alternate*pi; %for 180 deg rot	turtle.offset=-turtle.offset; % orthogonal offset. Positive is to right of straight ahead.	turtle.alternate=~turtle.alternate;else	clear screen; ShowCursor;	error(sprintf('Unknown turtle.gaborSet ''%s''. It must be ISO, ORTHO, ....',turtle.gaborSet))endgaborSize=5*max(turtle.spaceConstantDegX,turtle.spaceConstantDegY)/turtle.pixDeg;% Generate the signalsdx=turtle.pixDeg;x=1:gaborSize;x=(x-mean(x))*dx;if rem(gaborSize,2)==1	x=x+dx/2; % offset by half a pixel, so origin is between pixels. This makes the squarewave better-defined.end[X,Y]=meshgrid(x,x);g=atan2(turtle.direction(2),turtle.direction(1))+orient; % direction of path, plus deviation;newX = X*cos(g) - Y*sin(g);newY = X*sin(g) + Y*cos(g);% 10/5/98 dgp% This code formerly applied the gaussian space constants in the X-Y coordinates of the screen, now it does% it in the rotated coordinates of the gabor. newX is the direction along which the grating changes; newY% is the direction along which the grating doesn't change. Choose what you want by setting gratingCoordinates 0 or 1.gratingCoordinates=1;if gratingCoordinates	gaussian=exp(-(newX/turtle.spaceConstantDegX).^2 -(newY/turtle.spaceConstantDegY).^2);else	gaussianX=exp(-(X/turtle.spaceConstantDegX).^2);	if turtle.spaceConstantDegX==turtle.spaceConstantDegY		gaussianY=gaussianX';	else		gaussianY=exp(-(Y/turtle.spaceConstantDegY).^2);	end	gaussian=gaussianX.*gaussianY;endgabor=sin(newX*(2*pi*turtle.f)+ turtle.gaborPhase*pi/180).*gaussian;if ~isfield(turtle,'offset')	turtle.offset=0;endorthoAngle=atan2(turtle.direction(2),turtle.direction(1))+pi/2; % direction 90 deg to right of pathpx=ceil(turtle.position(1)+turtle.offset*cos(orthoAngle));py=ceil(turtle.position(2)+turtle.offset*sin(orthoAngle));global canvasif turtle.newLetter	canvas=zeros(turtle.canvasSize,turtle.canvasSize);endxx=turtle.canvasX0+px+round(x/dx);yy=turtle.canvasY0+py+round(x/dx);if ~all(diff(xx) == 1)    xx = xx(1) + [0:length(xx)-1];endif ~all(diff(yy) == 1)    yy = yy(1) + [0:length(yy)-1];endcanvas(xx,yy)=canvas(xx,yy)+gabor;% enforceLimits = isfield(turtle, 'enforceLimits') && isequal(turtle.enforceLimits, 1);enforceLimits = turtle.capGaborMagnitude;maxGaborAmplitude = max(abs(lims(gabor)));turtle.gaborMax = max(turtle.gaborMax, maxGaborAmplitude);if enforceLimits    canvas(canvas < -maxGaborAmplitude) = -maxGaborAmplitude;    canvas(canvas >  maxGaborAmplitude) =  maxGaborAmplitude;endif any(abs(canvas(:)) > maxGaborAmplitude*1.5)    3;endif turtle.animate	s=canvas(turtle.canvasX0+(1:turtle.signalSize),turtle.canvasY0+(1:turtle.signalSize));	s=flipud(s');	%fprintf('signal max %.1f min %.1f\n',max(max(s)),min(min(s)));	SCREEN(turtle.window,'PutImage',s*127/3+128)endturtle.newLetter=0;newTurtle=turtle;return