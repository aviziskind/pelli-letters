function signal=DrawLetterML(t,letter)% Draws a snake in the shape of a letter. As we trace the stroke of the letter,% we draw a mark every so often. Each mark is a gabor patch. They add.% Denis Pelli & Noah Raizman 17 July 1998% the basic turtle statet.position=[14 14];t.position=[10 4]; % perfect for tiny gabors (0.1 deg)t.position=[0 0];t.position=[t.signalSize-t.signalCoreSize,t.signalSize-t.signalCoreSize]/2;t.nextMark=1;if t.randSpacing	t.inkLength=floor(rand(1)*t.markSpacing/2);else	t.inkLength=0;endt.direction=[0,1];t.ink=1;t.print=0;	% each routine prints on the console each time it's calledif t.print	fprintf('DRAWLETTER "%c"\n',letter);endt.show=t.animate;	% show letter onscreen once it's computedt.newLetter=1;if t.show	r=[0 0 t.signalSize t.signalSize];	t.window=SCREEN(0,'OpenWindow',[],r);endt.canvasSize=t.signalSize+100;r=[0,0,t.signalCoreSize,t.signalCoreSize];canvasRect=[0,0,t.canvasSize,t.canvasSize];r=CenterRect(r,canvasRect);t.canvasX0=r(RectLeft);t.canvasY0=r(RectTop); % actually the bottom, using the convention that y increases upward	% Begin at the lower left corner of a 100x100 bounding box that contains the core of the strokes.switch letter		case 'H';		% Start at the bottom, draw left side;		t.ink=1;		t=Forward(t,100);		t=Turn(t,180);		t.ink=0;		t=Forward(t,50);		t=Turn(t,-90);		% Draw horizontal.;		t.ink=1;		t=Forward(t,80);		t=Turn(t,-90);		t.ink=0;		t=Forward(t,50);		t=Turn(t,180);		t.ink=1;		% Draw right side.;		t=Forward(t,100);			case 'L';		t.ink=1;		t=Forward(t,100);		t=Turn(t,180);		t.ink=0;		t=Forward(t,100);		t=Turn(t,-90);		t.ink=1;		t=Forward(t,80);			case 'E';		t.ink=0;		t=Turn(t,90);		t=Forward(t,80);		t=Turn(t,180);		t.ink=1;		t=Forward(t,90);		t=Turn(t,90);		t=Forward(t,50);		t=Turn(t,90);		t=Forward(t,60);		t.ink=0;		t=Turn(t,180);		t=Forward(t,60);		t=Turn(t,90);		t.ink=1;		t=Forward(t,50);		t=Turn(t,90);		t=Forward(t,90);			case 'V';		t.ink=0;		t=Forward(t,100);		t=Turn(t,157.5);		t.ink=1;		t=Forward(t,108);		t.ink=0;		t.direction=[0,1];		t=Turn(t,22.5);		t=Forward(t,10);		t.ink=1;		t=Forward(t,98);	case 'K';		t.ink=1;		t=Forward(t,100);		t.ink=0;		t=Turn(t,180);		t=Forward(t,60);		t=Turn(t,180);		t=Turn(t,50);		t.ink=1;		t=Forward(t,90);		t.ink=0;		t=Turn(t,180);		t=Forward(t,50);		t=Turn(t,-85);		t.ink=0;		t=Forward(t,80);		t=Turn(t,180);		t.ink=1;		t=Forward(t,80);	case 'C'		t.ink=0;		t=Forward(t,50); 		t.ink=1;			t=Curve(t,50,165);		t.ink=0;		t=Curve(t,50,40);		t.ink=1;		t=Curve(t,50,165);	case 'D'		t.ink=1;		t=Forward(t,100);		t=Turn(t,90);		t=Forward(t,62); % 10/5/98 reduced by 1 by dgp to stay withing bounding box		t=Curve(t,38,90);		t=Forward(t,24); % 10/5/98 reduced by 1 by dgp to stay withing bounding box		t=Curve(t,38,90);		t=Forward(t,62); % 10/5/98 reduced by 1 by dgp to stay withing bounding box	case 'Z'		t.ink=0;		t=Forward(t,100);		t=Turn(t,90);		t.ink=1;		t=Forward(t,100);		t=Turn(t,135);		t.ink=1;		t=Forward(t,100*sqrt(2));		t.ink=0;		t=Turn(t,-135);		t.ink=1;		t=Forward(t,100);	case 'N'		t=Forward(t,100);		t=Turn(t,135);		t=Forward(t,(100*sqrt(2)));		t.ink=0;		t=Turn(t,-135);		t.ink=1;		t=Forward(t,100);	case 'S'		t.ink=0;		t=Forward(t,25); % changed by dgp 10/5/98, moving the whole letter up 5, to fit in the bounding box		t=Turn(t,180);		t.ink=1;		t=Curve(t,-25,90);		t=Forward(t,40);		t=Curve(t,-25,180);		t=Forward(t,40);		t=Curve(t,25,180);		t=Forward(t,40);		t=Curve(t,25,90);	case 'R'		t.ink=1;		t=Forward(t,100);		t=Turn(t,90);		t.ink=1;		t=Forward(t,60);		t=Curve(t,25,180);		t=Turn(t,-111);		t=Forward(t,55);		t.ink=0;		t=Turn(t,180);		t=Forward(t,55);		t=Turn(t,-69);		t.ink=1;		t=Forward(t,60);			case 'Q'		t.position=[60,60];		t.direction=[.5,.5]		t=Mark(t);		pause		t=Curve(t,-30,90);		t=Curve(t,30,90);			otherwise		error(sprintf('The letter "%c" (%d) is not implemented.',letter,letter));endif t.print	fprintf('\n');endglobal canvassignal=canvas(t.canvasX0+(1:t.signalSize),t.canvasY0+(1:t.signalSize));signal=flipud(signal');if t.show	s=signal;	%fprintf('signal max %.1f min %.1f\n',max(max(s)),min(min(s)));	SCREEN(t.window,'PutImage',s*127/3+128)endreturn